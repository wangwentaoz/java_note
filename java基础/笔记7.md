## 网络
1. 相关概念
   1. java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信
   2. 网络分为三类：局域网、城域网、广域网
   3. ip地址
      1. 用于唯一标识网络中的每台计算机、主机
      2. ip地址组成：网络地址 + 主机地址，例如192.168.1.1
   4. 域名
      1. www.baidu.com
      2. 为了方便记忆，解决记ip的困难
      3. 将ip地址映射为域名
   5. 端口号
      1. 用于标识计算机上某个特定的网络程序
      2. 表示形式：整数， 0~65535 ，两个字节表示端口，0~2^16-1
      3. 0~1024 端口已经被占用，不要使用
      4. 常见的网络编程端口号
         1. tomcat 8080
         2. mysql 3306
         3. oracle 1521
         4. sqlserver 1433
   6. 网络通信协议 TCP\IP
      1. 传输控制协议、因特网互联协议，又叫网络通信协议
      2. 网络层的IP协议和传输层的TCP协议组成
      3. 在网络编程中，数据的组织形式就是协议
      4. TCP
         1. 使用TCP协议前，需要先建立TCP连接，形成传输数据通道
         2. 传输前，采用三次握手的方式，是可靠的
         3. TCP协议进行通信前的两个应用进程：客户端、服务端
         4. 在连接中进行大数据量的传输
         5. 传输完毕，释放已经建立的连接，效率低
      5. UDP
         1. 将数据、源、目的封装成数据包，不需要建立连接
         2. 每个数据包的大小限制在64k内
         3. 因无需连接，所以不可靠
         4. 发送数据结束时无需释放资源，因为不是面向连接的，速度快
2. InetAddress 类
   1. 相关方法
      1. getLocalHost：获取本机InetAddress对象
      2. getByName：根据指定主机名、域名获取InetAddress对象
      3. getHostName：通过InetAddress对象获取对应的主机名或域名
      4. getHostAddress：通过InetAddress对象获取对应的ip地址
3. Socket
   1. 基本介绍
      1. 套接字(Socket)开发网络应用程序被广泛采纳
      2. 通信两端都需要有Socket，是两台机器间通信的端点
      3. 网络通信其实就是Socket通信
      4. Socket允许程序把网络连接当成一个流，数据在两个Socket之间通过IO传输
      5. 一般主动发起通信的应用程序属于客户端，等待通信请求的是服务端
   2. 当我们需要通信时（读写数据）
      1. socket.getOutputStream()
      2. socket.getInputStream()
      3. 最后需要关闭连接 socket.close()
   3. 两种编程方式
      1. TCP网络通信编程，可靠
         1. 基于客户端-服务端的网络通信
         2. 底层使用TCP/IP协议
         3. 例：客户端发送数据，服务端接受并显示在控制台
         4. 基于Socket的TCP编程
         5. 服务端
            ```
            // 监听9999端口,等待连接 要求9999端口未被占用
            ServerSocket serverSocket = new ServerSocket(9999);
            // 当没有客户连接时，程序会阻塞；当有客户连接时，返回对象socket。可以通过accept方法返回多个Socket[多个客户端连接服务器的并发]
            Socket socket = serverSocket.accept();
            // 读取客户端发送的数据
            InputStream inputStream = socket.getInputStream();
            byte[] buf = new byte[1024];
            int readLen = 0;
            while((readLen = inputStream.read(buf)) != -1){
              sout(new String(buf, 0, readLen));
            }
            inputStream.close();
            socket.close();
            serverSocket.close();
            ```
         6. 客户端
            ```
            // 连接服务器，指定ip和端口，如果连接成功，返回socket对象
            Socket socket = new Socket(InetAddress.getLocalHost(), 9999) // 取到本机ip
            Socket socket = new Socket(168.1.1.1, 9999) //也可以是指定的ip
            //发送数据给服务端
            OutputStream outputStream = socket.getOutputStream();
            outputStream.write("hello Server".getBytes());
            // 设置写入结束标记
            // 如果是字符流也可以使用writer.newLine(),这时必须使用字符流readLine才能读取到
            // 如果是字符流,需要手动刷新，bufferedWriter.flush(); 否则数据不会写入数据通道
            socket.shutdownOutput();
            // 关闭流对象和socket
            outputStream.close()；
            socket.close();
            ```
         7. netstat指令
            1. netstat-an 可以查看当前主机网络情况，包括端口监听和网络连接情况
               1. 主要显示的内容是本机正在监听的ip和端口号(例如本机启动服务，监听8080端口)，并且显示外部连接到本机的地址
               2. Listening表示某个端口在监听
               3. 
            2. netstat-an|more 可以分页显示
               1. 要求在dos控制台下执行
         8. 当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通信的，这个端口通过TCP、IP来分配，是随机的
      2. UDP网络通信编程，不可靠
         1. 类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序
         2. UDP数据包通过数据包套接字 DatagramSocket 发送和接受，系统不保证UDP数据包一定能安全的到达目的地，也不确定什么时候到达
         3. DatagramPacket 对象封装了UDP数据包，在数据包中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
         4. UDP协议中每个数据包都给出了完整的地址信息，因此无序建立发送方和接受方的连接
         5. 基本流程
            1. 建立发送端、接收端，没有明确的服务端和客户端
            2. 建立数据包，被封装在DatagramPacket中
            3. 调用DatagramSocket的发送和接受方法，可以指定在哪个端口接收数据
            4. 关闭DatagramSocket
         6. DatagramPacket构造器
            1. DatagramPacket(byte[], int, int) 接受方
            2. DatagramPacket(byte[], int, int, InetAddress, int) 发送方，指定ip地址InetAddress和端口号int
         7. 接收端A
            ```
            // 创建DatagramSocket对象，准备在9999接受数据
            DatagramSocket socket = new DatagramSocket(9999);
            // 创建DatagramPacket对象，准备接受数据
            byte[] buf = new byte[1024];
            DatagramPacket packet = new DatagramPacket(buf, buf.length)
            // 调用接受方法接受数据,将接受到的数据填充到packet对象中.如果没有数据发送过来，会阻塞
            socket.receive(packet);
            //拆包，取出数据
            int length = packet.getLength();  // 实际接收到的数据的字节长度
            byte[] data = packet.getData();
            String s = new String(data, 0, length);
            //关闭资源
            socket.close(); 
            ```
         8. 发送端B
            ```
            // 创建DatagramSocket对象，准备在8888接受数据,发送端也可以转为接收端，即一旦有人给其发送数据，也可以进行接受
            DatagramSocket socket = new DatagramSocket(8888);
            // 将需要发送的数据装包
            byte[] data = "你好".getBytes();
            DatagramPacket s = new DatagramPacket(data, 0, data.length, InetAddress.getByName("192.168.1.1"), 9999)
            //发送
            socket.send(packet);
            socket.close();
            ```
4. 