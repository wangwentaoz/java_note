1. 抽象类
   1. 当父类的某些方法，需要声明，三十又不知道如何实现，可以将其声明为抽象方法，那么这个类就是抽象类
      1. 当一个类中存在抽象方法，那么就需要将该类声明为abstract类
      2. 由其子类来实现抽象方法，抽象方法不能有方法体
   2. 细节
      1. 抽象类不能被实例化
      2. 抽象类不一定包含abstract方法
      3. 一个类如果继承了抽象类，则必须实现抽象类的所有抽象方法，除非其本身是抽象类
      4. 抽象方法不能使用static、final、private修饰，因为这些修饰和子类的重写是违背的
2. 接口
   1. 接口就是给出一些没有实现的方法(抽象方法)，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来
      1. 在jdk7.0以前，接口里的所有方法都没有方法体
      2. jdk8.0后接口类可以有静态方法，默认方法(需要使用default关键字修饰)
   2. 细节
      1. 接口中所有的方法都是public方法，接口中的抽象方法可以省略abstract关键字
      2. 一个普通类实现接口，就需要把接口的所有方法全都实现，快捷键 alt + enter
      3. 抽象类实现接口，可以不用实现接口的方法
      4. 接口中的属性，只能是final的，而且是public static final
      5. 接口不可以继承类，但是可以继承接口
      6. 接口的修饰符只能默认或者public，即 public interface aaa{}
3. 内部类
   1. 一个类的内部又完整嵌套另一个类结构
      1. 内部类的最大特点就是可以直接访问私有属性，并且可以体现类之间的包含关系
   2. 分类
      1. 定义在外部类局部位置上(比如方法中)
         1. 局部内部类(有类名)
         1. 匿名内部类(没有类名)
      2. 定义在外部类的成员位置上
         1. 成员内部类(没用static修饰)
         2. 静态内部类(使用static修饰)
   3. 局部内部类
      1. 不能添加访问修饰符，因为它的地位就是局部变量，可以使用final修饰，不可被继承
      2. 如果外部类和局部内部类的成员重名时，遵守就近原则，如果想访问外部类的成员可以使用 外部类名.this.成员 访问 
         1. 外部类名.this 本质就是外部类的实例对象
   4. 匿名内部类
      1. 匿名内部类同时还是一个对象
          ```
          interface IA{}
          IA tiger = new IA(){}  // 基于接口(类也可以)创建一个匿名类并且创建了一个对象tiger
          class XXX implement IA{}  // 上面匿名类相当于这么创建的
          ```
         1. tiger就是匿名类创建的对象
      2. 不能添加访问修饰符，因为其就是一个局部变量
      3. 只能用一次，用完就消失了
      4. 最佳实践
         1. 当作实参传递
   5. 成员内部类
      1. 可以添加修饰符
   6. 静态内部类
      1. 可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态成员
      2. 可以添加修饰符
      3. 如果外部类和静态内部类成员重名时，访问外部类可以通过 外部类名.成员 访问，因为这是成员一般是取静态的，就不需要 外部类名.this 取到实例对象了
4. 枚举和注解
   1. 枚举
      1. 枚举是一组常量的集合
         1. 可以理解为枚举属于一种特殊的类，里面只包含一组有限的特定的对象
      2. 实现方式
         1. 自定义类实现
         2. 使用enum关键字
            1. 要求将定义常量对象写在枚举类的行首，多个常量用逗号分隔，最后分号结尾
            2. 默认继承Enum类，而且是要给final类。public static final Season SPRING = new Spring("春天", "温暖") 被简化为 SPRING("春天", "温暖")
            3. 